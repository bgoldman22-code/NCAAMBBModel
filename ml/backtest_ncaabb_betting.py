#!/usr/bin/env python3
"""
Backtest NCAA Basketball betting strategy using calculated edges.

This script:
1. Loads edges CSV (output from generate_ncaabb_edges.py)
2. Applies bet filters (min edge thresholds)
3. Simulates flat-stake betting
4. Calculates ATS%, Moneyline%, ROI by bet type

Usage:
    python3 ml/backtest_ncaabb_betting.py \
        --edges-file data/edges/edges_ncaabb_2024.csv \
        --min-edge-spread 1.5 \
        --min-edge-ml 0.05 \
        --stake 100

Options:
    --min-edge-spread: Minimum spread edge (in points) to bet
    --min-edge-ml: Minimum moneyline edge (probability) to bet
    --stake: Flat stake amount per bet (default: 100 units)
    --output-summary: Save summary report to file
"""

import argparse
from pathlib import Path
import pandas as pd
import numpy as np
from typing import Tuple


def load_edges(edges_path: Path) -> pd.DataFrame:
    """Load edges CSV generated by generate_ncaabb_edges.py"""
    if not edges_path.exists():
        raise FileNotFoundError(f"Edges file not found: {edges_path}")
    
    df = pd.read_csv(edges_path)
    
    print(f"‚úÖ Loaded {len(df):,} games from {edges_path.name}")
    print(f"   Date range: {df['game_day'].min()} ‚Üí {df['game_day'].max()}")
    
    return df


def parse_result(result_str: str) -> Tuple[str, int, int]:
    """
    Parse game result string to extract outcome and score.
    
    Args:
        result_str: Game result (e.g., "W 92-54", "L 68-70")
        
    Returns:
        (outcome, team_score, opponent_score)
        outcome is 'W' or 'L'
    """
    parts = result_str.strip().split()
    outcome = parts[0]
    scores = parts[1].split('-')
    team_score = int(scores[0])
    opponent_score = int(scores[1])
    
    return outcome, team_score, opponent_score


def evaluate_spread_bet(
    team_score: int,
    opponent_score: int,
    close_spread: float,
    edge_spread: float
) -> dict:
    """
    Evaluate spread bet outcome.
    
    Args:
        team_score: Home team (perspective team) score
        opponent_score: Away team score
        close_spread: Market spread (from home perspective)
        edge_spread: Model edge (model_spread - close_spread)
        
    Returns:
        Dict with:
            - bet_side: 'home' or 'away'
            - actual_margin: team_score - opponent_score
            - covered: True if bet won
            - result: profit/loss (1.0 for win, -1.1 for loss including vig)
    """
    actual_margin = team_score - opponent_score
    
    # Bet on side where model sees value
    if edge_spread > 0:
        # Model likes home more than market ‚Üí bet home
        bet_side = 'home'
        covered = actual_margin > close_spread
    else:
        # Model likes away more than market ‚Üí bet away
        bet_side = 'away'
        covered = actual_margin < close_spread
    
    # Standard spread bet: risk 1.1 to win 1.0 (-110 juice)
    result = 1.0 if covered else -1.1
    
    return {
        'bet_side': bet_side,
        'actual_margin': actual_margin,
        'covered': covered,
        'result': result
    }


def evaluate_moneyline_bet(
    outcome: str,
    home_ml: int,
    away_ml: int,
    home_ml_edge: float,
    away_ml_edge: float
) -> dict:
    """
    Evaluate moneyline bet outcome.
    
    Args:
        outcome: Game outcome ('W' if home won, 'L' if home lost)
        home_ml: Home team moneyline (American odds)
        away_ml: Away team moneyline (American odds)
        home_ml_edge: Model edge for home ML
        away_ml_edge: Model edge for away ML
        
    Returns:
        Dict with:
            - bet_side: 'home' or 'away'
            - won: True if bet won
            - result: profit/loss based on American odds
    """
    home_won = (outcome == 'W')
    
    # Bet on side with highest edge
    if home_ml_edge > away_ml_edge:
        bet_side = 'home'
        won = home_won
        odds = home_ml
    else:
        bet_side = 'away'
        won = not home_won
        odds = away_ml
    
    # Calculate profit/loss from American odds
    if won:
        if odds < 0:
            # Favorite: risk |odds| to win 100
            result = 100 / abs(odds)
        else:
            # Underdog: risk 100 to win odds
            result = odds / 100
    else:
        result = -1.0  # Lost stake
    
    return {
        'bet_side': bet_side,
        'won': won,
        'result': result
    }


def backtest_strategy(
    df: pd.DataFrame,
    min_edge_spread: float = 1.5,
    min_edge_ml: float = 0.05,
    stake: float = 100.0
) -> dict:
    """
    Backtest betting strategy with given filters.
    
    Args:
        df: DataFrame with edges and game results
        min_edge_spread: Minimum absolute spread edge to bet (in points)
        min_edge_ml: Minimum absolute ML edge to bet (probability)
        stake: Flat stake amount per bet
        
    Returns:
        Dict with backtest results:
            - spread_bets: List of spread bet results
            - ml_bets: List of moneyline bet results
            - summary: Aggregate statistics
    """
    spread_bets = []
    ml_bets = []
    
    for _, row in df.iterrows():
        # Parse game result
        outcome, team_score, opponent_score = parse_result(row['game_result'])
        
        # Evaluate spread bets
        if abs(row['edge_spread']) >= min_edge_spread:
            bet_result = evaluate_spread_bet(
                team_score=team_score,
                opponent_score=opponent_score,
                close_spread=row['close_spread'],
                edge_spread=row['edge_spread']
            )
            bet_result['game_day'] = row['game_day']
            bet_result['team'] = row['team']
            bet_result['opponent'] = row['opponent']
            bet_result['edge'] = row['edge_spread']
            bet_result['profit'] = bet_result['result'] * stake
            spread_bets.append(bet_result)
        
        # Evaluate moneyline bets
        if max(abs(row['home_ml_edge']), abs(row['away_ml_edge'])) >= min_edge_ml:
            bet_result = evaluate_moneyline_bet(
                outcome=outcome,
                home_ml=row['home_ml'],
                away_ml=row['away_ml'],
                home_ml_edge=row['home_ml_edge'],
                away_ml_edge=row['away_ml_edge']
            )
            bet_result['game_day'] = row['game_day']
            bet_result['team'] = row['team']
            bet_result['opponent'] = row['opponent']
            bet_result['edge'] = row['home_ml_edge'] if bet_result['bet_side'] == 'home' else row['away_ml_edge']
            bet_result['profit'] = bet_result['result'] * stake
            ml_bets.append(bet_result)
    
    # Calculate summary statistics
    summary = {
        'total_games': len(df),
        'spread_bets': len(spread_bets),
        'ml_bets': len(ml_bets),
    }
    
    # Spread statistics
    if spread_bets:
        spread_df = pd.DataFrame(spread_bets)
        summary['spread_wins'] = spread_df['covered'].sum()
        summary['spread_win_pct'] = spread_df['covered'].mean() * 100
        summary['spread_profit'] = spread_df['profit'].sum()
        summary['spread_roi'] = (spread_df['profit'].sum() / (len(spread_bets) * stake)) * 100
    else:
        summary['spread_wins'] = 0
        summary['spread_win_pct'] = 0
        summary['spread_profit'] = 0
        summary['spread_roi'] = 0
    
    # Moneyline statistics
    if ml_bets:
        ml_df = pd.DataFrame(ml_bets)
        summary['ml_wins'] = ml_df['won'].sum()
        summary['ml_win_pct'] = ml_df['won'].mean() * 100
        summary['ml_profit'] = ml_df['profit'].sum()
        summary['ml_roi'] = (ml_df['profit'].sum() / (len(ml_bets) * stake)) * 100
    else:
        summary['ml_wins'] = 0
        summary['ml_win_pct'] = 0
        summary['ml_profit'] = 0
        summary['ml_roi'] = 0
    
    # Combined statistics
    total_profit = summary['spread_profit'] + summary['ml_profit']
    total_bets = summary['spread_bets'] + summary['ml_bets']
    summary['total_profit'] = total_profit
    summary['total_roi'] = (total_profit / (total_bets * stake) * 100) if total_bets > 0 else 0
    
    return {
        'spread_bets': spread_bets,
        'ml_bets': ml_bets,
        'summary': summary
    }


def print_summary(results: dict, stake: float):
    """Print formatted backtest summary"""
    summary = results['summary']
    
    print("\n" + "="*80)
    print("BACKTEST RESULTS")
    print("="*80)
    
    print(f"\nüìä Overview:")
    print(f"   Total games analyzed: {summary['total_games']:,}")
    print(f"   Total bets placed:    {summary['spread_bets'] + summary['ml_bets']:,}")
    print(f"   Stake per bet:        {stake:.0f} units")
    
    print(f"\nüéØ Spread Betting:")
    print(f"   Bets placed:  {summary['spread_bets']:,}")
    print(f"   Wins:         {summary['spread_wins']}")
    print(f"   Win rate:     {summary['spread_win_pct']:.1f}%")
    print(f"   Profit:       {summary['spread_profit']:+.2f} units")
    print(f"   ROI:          {summary['spread_roi']:+.2f}%")
    
    print(f"\nüí∞ Moneyline Betting:")
    print(f"   Bets placed:  {summary['ml_bets']:,}")
    print(f"   Wins:         {summary['ml_wins']}")
    print(f"   Win rate:     {summary['ml_win_pct']:.1f}%")
    print(f"   Profit:       {summary['ml_profit']:+.2f} units")
    print(f"   ROI:          {summary['ml_roi']:+.2f}%")
    
    print(f"\nüìà Combined Results:")
    print(f"   Total profit: {summary['total_profit']:+.2f} units")
    print(f"   Total ROI:    {summary['total_roi']:+.2f}%")
    
    # Break-even analysis
    spread_be = 52.4  # Need 52.4% to break even at -110
    ml_be = 50.0  # Approximate (depends on odds distribution)
    
    print(f"\nüéì Break-Even Analysis:")
    print(f"   Spread BE: {spread_be:.1f}% (actual: {summary['spread_win_pct']:.1f}%)")
    spread_diff = summary['spread_win_pct'] - spread_be
    print(f"   ‚Üí {'+' if spread_diff > 0 else ''}{spread_diff:.1f}% {'above' if spread_diff > 0 else 'below'} break-even")
    
    if summary['ml_bets'] > 0:
        print(f"   ML BE: ~{ml_be:.1f}% (actual: {summary['ml_win_pct']:.1f}%)")
        ml_diff = summary['ml_win_pct'] - ml_be
        print(f"   ‚Üí {'+' if ml_diff > 0 else ''}{ml_diff:.1f}% {'above' if ml_diff > 0 else 'below'} break-even")


def save_summary_report(results: dict, output_path: Path, stake: float, args):
    """Save backtest summary to text file"""
    summary = results['summary']
    
    with open(output_path, 'w') as f:
        f.write("NCAA BASKETBALL BETTING BACKTEST SUMMARY\n")
        f.write("=" * 80 + "\n\n")
        
        f.write("Configuration:\n")
        f.write(f"  Edges file: {args.edges_file}\n")
        f.write(f"  Min spread edge: {args.min_edge_spread} points\n")
        f.write(f"  Min ML edge: {args.min_edge_ml:.1%}\n")
        f.write(f"  Stake: {stake} units\n\n")
        
        f.write("Results:\n")
        f.write(f"  Total games: {summary['total_games']:,}\n")
        f.write(f"  Spread bets: {summary['spread_bets']:,} ({summary['spread_win_pct']:.1f}% win rate)\n")
        f.write(f"  ML bets: {summary['ml_bets']:,} ({summary['ml_win_pct']:.1f}% win rate)\n")
        f.write(f"  Total profit: {summary['total_profit']:+.2f} units\n")
        f.write(f"  Total ROI: {summary['total_roi']:+.2f}%\n\n")
        
        f.write("Spread betting:\n")
        f.write(f"  Wins: {summary['spread_wins']}/{summary['spread_bets']}\n")
        f.write(f"  Profit: {summary['spread_profit']:+.2f} units\n")
        f.write(f"  ROI: {summary['spread_roi']:+.2f}%\n\n")
        
        f.write("Moneyline betting:\n")
        f.write(f"  Wins: {summary['ml_wins']}/{summary['ml_bets']}\n")
        f.write(f"  Profit: {summary['ml_profit']:+.2f} units\n")
        f.write(f"  ROI: {summary['ml_roi']:+.2f}%\n")
    
    print(f"\n‚úÖ Summary report saved to {output_path}")


def main():
    parser = argparse.ArgumentParser(
        description="Backtest NCAA Basketball betting strategy"
    )
    parser.add_argument(
        '--edges-file',
        type=Path,
        required=True,
        help="Path to edges CSV (from generate_ncaabb_edges.py)"
    )
    parser.add_argument(
        '--min-edge-spread',
        type=float,
        default=1.5,
        help="Minimum spread edge in points (default: 1.5)"
    )
    parser.add_argument(
        '--min-edge-ml',
        type=float,
        default=0.05,
        help="Minimum moneyline edge as probability (default: 0.05 = 5%%)"
    )
    parser.add_argument(
        '--stake',
        type=float,
        default=100.0,
        help="Flat stake per bet in units (default: 100)"
    )
    parser.add_argument(
        '--output-summary',
        type=Path,
        help="Optional: Save summary report to file"
    )
    
    args = parser.parse_args()
    
    print("="*80)
    print("NCAA BASKETBALL BETTING BACKTEST")
    print("="*80)
    
    # Load edges
    print(f"\n1Ô∏è‚É£ Loading edges from {args.edges_file}...")
    edges_df = load_edges(args.edges_file)
    
    # Run backtest
    print(f"\n2Ô∏è‚É£ Running backtest...")
    print(f"   Min spread edge: {args.min_edge_spread} points")
    print(f"   Min ML edge:     {args.min_edge_ml:.1%}")
    print(f"   Stake:           {args.stake} units")
    
    results = backtest_strategy(
        df=edges_df,
        min_edge_spread=args.min_edge_spread,
        min_edge_ml=args.min_edge_ml,
        stake=args.stake
    )
    
    # Print results
    print_summary(results, args.stake)
    
    # Save summary if requested
    if args.output_summary:
        save_summary_report(results, args.output_summary, args.stake, args)
    
    print(f"\n‚úÖ Backtest complete!")


if __name__ == '__main__':
    main()
